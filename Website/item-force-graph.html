--- ---
<!DOCTYPE html>
<html>

<head>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://gitcdn.xyz/repo/MasterMaps/d3-slider/master/d3.slider.js"></script>
    <link rel='stylesheet' href="https://gitcdn.xyz/repo/MasterMaps/d3-slider/master/d3.slider.css">
    <link rel='stylesheet' type='text/css' href='/css/force.css'>
</head>

<body>
    <div id='min-link'></div>
    <script>
    function createForce() {
        var self = this;
        self.addNode = function(version, id, size) {
            nodes.push({
                version: version,
                id: id,
                size: size,
                focus: true,
                visible: true,
            });
            return self;
        };

        self.editNode = function(version, id, size) {
            findNode(version, id).size = size;
            return self;
        }

        self.removeNode = function(id) {
            var i = 0;
            var n = findNode(id);
            while (i < links.length) {
                if ((links[i]['source'] == n) || (links[i]['target'] == n)) {
                    links.splice(i, 1);
                } else i++;
            }
            nodes.splice(findNodeIndex(id), 1);
            return self;
        };

        self.addLink = function(version, source, target, strength) {
            links.push({
                version: version,
                "source": findNode(source),
                "target": findNode(target),
                "value": strength,
                focus: true,
                visible: true
            });
            return self;
        };

        self.editLink = function(source, target, strength) {
            findLink(source, target).value = strength;
            return self;
        }

        self.appendTo = function(parent) {
            parent.appendChild(svg[0][0]);
            return self;
        }

        self.setVersion = function(v) {
            version = v;
            refreshVisible();
            return self;
        }

        self.linkMinimum = function(min) {
            if (typeof arguments[0] === 'undefined') {
                return linkMinimumValue;
            }
            linkMinimumValue = min;
            refreshVisible();
            return self;
        }

        var refreshVisible = function() {
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                if (n.version !== version) {
                    n.visible = false;
                } else if (n.focus === false) {
                    n.visible = false;
                } else if (!findNodeLinks(n).map(function(l) {
                        return l.value;
                    }).reduce(function(prev, curr) {
                        return prev || curr >= linkMinimumValue;
                    }, false)) {
                    n.visible = false;
                } else {
                    n.visible = true;
                }
            }
            for (var linkNum = 0; linkNum < links.length; linkNum++) {
                var l = links[linkNum];
                if (l.version !== version) {
                    l.visible = false;
                } else if (l.value < linkMinimumValue) {
                    l.visible = false;
                } else if (l.focus === false) {
                    l.visible = false;
                } else {
                    l.visible = true;
                }
            }
        }

        var findNode = function(id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i]["id"] === id) {
                    return nodes[i];
                }
            };
        };

        var findNodeIndex = function(id) {
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id == id) {
                    return i;
                }
            };
        };

        var findLink = function(source, target) {
            for (var i = 0; i < links.length; i++) {
                if (links[i].source.id == source && links[i].target.id == target) {
                    return links[i]
                } else if (links[i].source.id == target && links[i].target.id == source) {
                    return links[i]
                }
            }
            return null;
        }

        var findNodeLinks = function(source) {
            var retLinks = [];
            for (var i = 0; i < links.length; i++) {
                if (links[i].source == source || links[i].target == source) {
                    retLinks.push(links[i]);
                }
            }
            return retLinks;
        }

        // set up the D3 visualisation in the specified element
        var w = $('body').width(),
            h = $('body').height();

        var color = d3.scale.category10();

        var svg = d3.select(document.createElementNS("http://www.w3.org/2000/svg", "svg"))
            .attr("width", w)
            .attr("height", h);
        var vis = svg
            .append('svg:g');

        var force = d3.layout.force();

        var nodes = force.nodes(),
            links = force.links();

        var focused = false;
        var version;
        var linkMinimumValue;

        self.update = function() {
            var linkSizes = links.map(function(l) {
                return l.value;
            });
            var smallestLink = d3.min(linkSizes);
            var largestLink = d3.max(linkSizes);
            var linkStrengthScale = d3.scale.linear()
                .domain([0, largestLink])
                .range([0, 1]);
            var strokeScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([1, 10]);
            var linkDistanceScale = d3.scale.pow()
                .domain([smallestLink, largestLink])
                .range([300, 70]);
            var nodeSizeScale = d3.scale.pow()
                .domain([0, 1])
                .range([10, 50]);

            var link = vis.selectAll("line")
                .data(links, function(d) {
                    return d.source.id + "-" + d.target.id;
                });

            link.enter().append("line")
                .attr("id", function(d) {
                    return d.source.id + "-" + d.target.id;
                })
                .classed("link", true)
                .attr('stroke-width', 0);
            link
                .transition()
                .attr("stroke-width", function(d) {
                    return d.visible ? strokeScale(d.value) : 0;
                });
            link.exit()
                .transition()
                .attr('stroke-width', 0)
                .remove();

            var node = vis.selectAll("g.node")
                .data(nodes, function(d) {
                    return d.id;
                });
            node.exit()
                .transition()
                .remove();
            var nodeEnter = node.enter()
                .append("g")
                .classed("node", true)
                .classed('sendToTop', true)
                .call(force.drag)
                .on('dblclick', function(d) {
                    if (focused) {
                        for (var i = 0; i < nodes.length; i++) {
                            nodes[i].focus = true;
                        }
                        for (var linkNum = 0; linkNum < links.length; linkNum++) {
                            links[linkNum].focus = true;
                        }
                    } else {
                        // Focus an element
                        for (var i = 0; i < nodes.length; i++) {
                            var n = nodes[i];
                            var nLink = findLink(d.id, n.id);
                            // Remove a node
                            if (d.id != n.id && nLink == null) {
                                // Remove and store all links
                                for (var linkNum = 0; linkNum < links.length; linkNum++) {
                                    if ((links[linkNum]['source'] == n) || (links[linkNum]['target'] == n)) {
                                        links[linkNum].focus = false;
                                    }
                                }
                                n.focus = false;
                            }
                        }
                    }
                    focused = !focused;
                    refreshVisible();
                    update();
                });
            nodeEnter.append("svg:circle")
                .attr("id", function(d) {
                    return "Node;" + d.id;
                })
                .attr('stroke', 'none')
                .attr('r', 0);
            node.select('circle')
                .attr("fill", function(d) {
                    return d.visible ? color(d.id) : 'none';
                })
                .transition()
                .attr("r", function(d) {
                    return d.visible ? nodeSizeScale(d.size) : 0;
                });
            node.exit().select('circle')
                .transition()
                .attr('r', 0);
            nodeEnter.append('defs')
                .append('clipPath')
                .attr('id', function(d, i) {
                    return 'circle' + i;
                })
                .append('circle')
                .attr('r', 0);
            node.select('defs>clipPath>circle')
                .transition()
                .attr("r", function(d) {
                    return d.visible ? nodeSizeScale(d.size) / 1.2 : 0;
                });
            node.exit().select('defs>clipPath>circle')
                .transition()
                .attr('r', 0);
            nodeEnter.append('image')
                .attr('clip-path', function(d, i) {
                    return 'url(#circle' + i + ')';
                })
                .attr('xlink:href', function(d) {
                    return 'http://ddragon.leagueoflegends.com/cdn/' + d.version + '.1/img/item/' + d.id + '.png'
                });
            node.select('image')
                .attr('width', function(d) {
                    return d.visible ? 2 * nodeSizeScale(d.size) / 1.2 : 0;
                })
                .attr('height', function(d) {
                    return d.visible ? 2 * nodeSizeScale(d.size) / 1.2 : 0;
                })
                .attr('x', function() {
                    return -d3.select(this).attr('width') / 2;
                })
                .attr('y', function() {
                    return -d3.select(this).attr('height') / 2;
                });
            node.exit().select('image')
                .transition()
                .attr('width', 0)
                .attr('height', 0)
                .attr('x', 0)
                .attr('y', 0);

            // because of the way the network is created, nodes are created first, and links second,
            // so the lines were on top of the nodes, this just reorders the DOM to put the svg:g on top
            $(".sendToTop").each(function(index) {
                this.parentNode.appendChild(this);
            });

            force.on("tick", function() {
                node.attr("transform", function(d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

                link.attr("x1", function(d) {
                        return d.source.x;
                    })
                    .attr("y1", function(d) {
                        return d.source.y;
                    })
                    .attr("x2", function(d) {
                        return d.target.x;
                    })
                    .attr("y2", function(d) {
                        return d.target.y;
                    });
            });

            // Restart the force layout.
            force
                .gravity(0.1)
                .charge(-10000)
                .friction(0.1)
                .linkDistance(function(d) {
                    return d.source.size + d.target.size + linkDistanceScale(findLink(d.source.id, d.target.id).value);
                })
                .linkStrength(function(d) {
                    return linkStrengthScale(d.value);
                })
                .size([w, h])
                .start();
            return self;
        };

        // Make it all go
        linkMinimum(0.3);
        update();
        return this;
    }

    var graph = createForce()
        .appendTo(document.body);

    d3.select('#min-link').call(d3.slider()
        .scale(d3.scale.linear().domain([0, 1]))
        .axis(d3.svg.axis())
        .snap(true)
        .value(graph.linkMinimum())
        .on('slide', function(evt, value) {
            graph.linkMinimum(value)
                .update();
        }));

    $.getJSON('/data/itemCross.json').then(function(data) {
        for (var i = 0; i < data.nodes.length; i++) {
            var node = data.nodes[i];
            graph.addNode(node.version, node.id, node.winRate);
        };
        for (var i = 0; i < data.links.length; i++) {
            var link = data.links[i];
            graph.addLink(link.version, link.source, link.target, link.value);
        };
        graph
            .setVersion('5.11')
            .update();
    });
    </script>
</body>

</html>
